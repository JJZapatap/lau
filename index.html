<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Control Charts (X̄–R / X̄–S)</title>
  <style>
    :root { --fg:#0f172a; --muted:#475569; --accent:#2563eb; --ok:#16a34a; --warn:#dc2626; --bg:#ffffff; }
    html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);font-family:ui-sans-serif,system-ui,Segoe UI,Roboto;}
    header{padding:16px 20px;border-bottom:1px solid #e2e8f0;display:flex;align-items:center;gap:12px;flex-wrap:wrap}
    h1{font-size:18px;margin:0;}
    .wrap{max-width:1100px;margin:0 auto;padding:16px;}
    .grid{display:grid;grid-template-columns:1fr;gap:16px;}
    @media(min-width:960px){ .grid{grid-template-columns:1fr 1fr;} }
    .card{border:1px solid #e2e8f0;border-radius:12px;padding:14px;}
    .muted{color:var(--muted);font-size:13px;}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;}
    svg{width:100%;height:280px;display:block;}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px;border:1px solid #e2e8f0;margin-right:6px;}
    .ooc{color:var(--warn);}
    .btn{display:inline-block;padding:8px 12px;border-radius:8px;border:1px solid #e2e8f0;background:#f8fafc;cursor:pointer;}
    .btn:active{transform:translateY(1px);}
    details{border:1px dashed #e2e8f0;border-radius:10px;padding:10px;}
    summary{cursor:pointer;}
    footer{padding:16px 20px;color:#64748b;font-size:12px;}
    .small{font-size:12px;}
    .mt8{margin-top:8px;}
    .inputs{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .inputs label{font-size:12px;color:#334155}
    .inputs input{padding:6px 8px;border:1px solid #e2e8f0;border-radius:8px}
    .danger{color:var(--warn)}
    .success{color:var(--ok)}
  </style>
</head>
<body>
  <header>
    <h1>Control Charts • X̄–R / X̄–S</h1>
    <span class="pill">CSV local</span>
    <span id="status" class="pill">Listo para cargar CSV</span>
  </header>

  <div class="wrap">
    <div class="card">
      <div class="inputs">
        <div>
          <label>CSV:</label>
          <input id="fileCsv" type="file" accept=".csv,text/csv" />
        </div>
        <div>
          <label>LSL:</label>
          <input id="lsl" type="number" step="any" placeholder="Ej. 95">
        </div>
        <div>
          <label>USL:</label>
          <input id="usl" type="number" step="any" placeholder="Ej. 105">
        </div>
        <button class="btn" id="btnProcesar">Procesar</button>
        <button class="btn" id="btnEjemplo">Probar con datos ejemplo</button>
      </div>
      <p class="muted mt8">
        Formato recomendado: cada <b>fila</b> es un subgrupo y cada columna una observación (n entre 2–10).
        Si el archivo viene “al revés”, lo detecto y lo roto automáticamente.
      </p>
      <div id="summary"></div>
      <div id="ooc"></div>
    </div>

    <div class="grid">
      <div class="card"><h3>Carta R</h3><svg id="svgR"></svg></div>
      <div class="card"><h3>Carta X̄ (basada en R)</h3><svg id="svgXR"></svg></div>
      <div class="card"><h3>Carta S</h3><svg id="svgS"></svg></div>
      <div class="card"><h3>Carta X̄ (basada en S)</h3><svg id="svgXS"></svg></div>
    </div>

    <details class="mt8">
      <summary>Ver datos procesados</summary>
      <pre class="small mono" id="debug"></pre>
    </details>
  </div>

  <footer class="wrap">Hecho para web estática (GitHub Pages) • Usa constantes AIAG por n (2–10).</footer>

<script>
/* ===================== UTILIDADES ===================== */
const CONSTS = {
  2:{d2:1.128,c4:0.7979,A2:1.880,D3:0.000,D4:3.267,A3:2.659,B3:0.000,B4:3.267},
  3:{d2:1.693,c4:0.8862,A2:1.023,D3:0.000,D4:2.574,A3:1.954,B3:0.000,B4:2.568},
  4:{d2:2.059,c4:0.9213,A2:0.729,D3:0.000,D4:2.282,A3:1.628,B3:0.000,B4:2.266},
  5:{d2:2.326,c4:0.9400,A2:0.577,D3:0.000,D4:2.114,A3:1.427,B3:0.000,B4:2.089},
  6:{d2:2.534,c4:0.9515,A2:0.483,D3:0.000,D4:2.004,A3:1.287,B3:0.030,B4:1.970},
  7:{d2:2.704,c4:0.9594,A2:0.419,D3:0.076,D4:1.924,A3:1.182,B3:0.118,B4:1.882},
  8:{d2:2.847,c4:0.9650,A2:0.373,D3:0.136,D4:1.864,A3:1.099,B3:0.185,B4:1.815},
  9:{d2:2.970,c4:0.9693,A2:0.337,D3:0.184,D4:1.816,A3:1.032,B3:0.239,B4:1.761},
 10:{d2:3.078,c4:0.9727,A2:0.308,D3:0.223,D4:1.777,A3:0.975,B3:0.284,B4:1.716}
};
function mean(a){ return a.reduce((s,v)=>s+v,0)/a.length; }
function stdevSample(a){ const m=mean(a); return Math.sqrt(a.reduce((s,v)=>s+(v-m)*(v-m),0)/(a.length-1)); }
function min(a){ return Math.min.apply(null,a); }
function max(a){ return Math.max.apply(null,a); }
function rnd(x, k=4){ return Math.round(x*Math.pow(10,k))/Math.pow(10,k); }
function transpose(m){ return m[0].map((_,i)=>m.map(r=>r[i])); }

/* ===================== PARSE CSV ===================== */
function detectSep(line){
  const c = {',': (line.match(/,/g)||[]).length,
             ';': (line.match(/;/g)||[]).length,
             '\t': (line.match(/\t/g)||[]).length};
  return Object.entries(c).sort((a,b)=>b[1]-a[1])[0][0];
}
function parseCSV(text){
  const lines = text.split(/\r?\n/).map(s=>s.trim()).filter(s=>s.length>0);
  if(!lines.length) throw new Error("CSV vacío.");
  const sep = detectSep(lines[0]);
  const rows = lines.map(row=>{
    return row.split(sep).map(tok=>{
      // Si separador es ';', asumir decimales con ',' -> convertir a '.'
      const t = (sep===';') ? tok.replace(',', '.') : tok;
      const v = Number(t.trim());
      return Number.isFinite(v) ? v : NaN;
    });
  });
  // eliminar filas totalmente NaN
  const filtered = rows.filter(r=>r.some(v=>Number.isFinite(v)));
  // Normalizar: igualar largo al máximo encontrado
  const mlen = Math.max(...filtered.map(r=>r.filter(Number.isFinite).length));
  const matrix = filtered.map(r=>r.filter(Number.isFinite).slice(0, mlen));
  if(!matrix.length || !mlen) throw new Error("No se detectaron valores numéricos.");
  return matrix;
}

/* Decide orientación: filas=subgrupos si columnas (n) está en [2..10]; si no, trasponer si filas (n2) está en [2..10] */
function orientGroups(mat){
  const m = mat.length, n = mat[0].length;
  if(n>=2 && n<=10 && m>=2) return {data: mat, n, m, mode:"rows=subgrupos"};
  const t = transpose(mat);
  const m2 = t.length, n2 = t[0].length; // ahora filas=t.length
  if(n2>=2 && n2<=10 && m2>=2) return {data: t, n: n2, m: m2, mode:"cols=subgrupos (transpuesto)"};
  // como fallback: usar mat y cortar n a 10 si fuese gigante
  const nFix = Math.min(n, 10);
  const fixed = mat.map(r=>r.slice(0,nFix)).filter(r=>r.length===nFix);
  if(!(nFix>=2)) throw new Error("No se pudo determinar un tamaño de subgrupo válido (n∈[2..10]).");
  return {data: fixed, n:nFix, m:fixed.length, mode:"fallback"};
}

/* ===================== CÁLCULOS ===================== */
function computeAll(data, n, m, lsl, usl){
  const C = CONSTS[n];
  if(!C) throw new Error("n no soportado (use 2–10).");

  const xbar = data.map(g=>mean(g));
  const R = data.map(g=>max(g)-min(g));
  const S = data.map(g=>stdevSample(g));

  const xbarbar = mean(xbar);
  const Rbar = mean(R);
  const Sbar = mean(S);

  // Límites X̄–R
  const UCL_R = C.D4 * Rbar, LCL_R = C.D3 * Rbar;
  const UCL_XR = xbarbar + C.A2*Rbar, LCL_XR = xbarbar - C.A2*Rbar;

  // Límites X̄–S
  const UCL_S = C.B4 * Sbar, LCL_S = C.B3 * Sbar;
  const UCL_XS = xbarbar + C.A3*Sbar, LCL_XS = xbarbar - C.A3*Sbar;

  // Fuera de control
  const idx = [...Array(m).keys()].map(i=>i+1);
  const ooc_R  = idx.filter(i=> R[i-1]  > UCL_R || R[i-1]  < LCL_R);
  const ooc_XR = idx.filter(i=> xbar[i-1] > UCL_XR || xbar[i-1] < LCL_XR);
  const ooc_S  = idx.filter(i=> S[i-1]  > UCL_S || S[i-1]  < LCL_S);
  const ooc_XS = idx.filter(i=> xbar[i-1] > UCL_XS || xbar[i-1] < LCL_XS);

  // Capacidad (opcional, si hay LSL/USL válidos)
  let cap = null;
  if(Number.isFinite(lsl) && Number.isFinite(usl) && usl>lsl){
    const sigma_R = Rbar / C.d2;
    const sigma_S = Sbar / C.c4;
    const Cp_R  = (usl - lsl) / (6*sigma_R);
    const Cpl_R = (xbarbar - lsl) / (3*sigma_R);
    const Cpu_R = (usl - xbarbar) / (3*sigma_R);
    const Cpk_R = Math.min(Cpl_R, Cpu_R);

    const Cp_S  = (usl - lsl) / (6*sigma_S);
    const Cpl_S = (xbarbar - lsl) / (3*sigma_S);
    const Cpu_S = (usl - xbarbar) / (3*sigma_S);
    const Cpk_S = Math.min(Cpl_S, Cpu_S);

    cap = { sigma_R, Cp_R, Cpk_R, Cpl_R, Cpu_R, sigma_S, Cp_S, Cpk_S, Cpl_S, Cpu_S };
  }

  return {
    xbar,R,S,xbarbar,Rbar,Sbar,
    UCL_R,LCL_R,UCL_XR,LCL_XR,
    UCL_S,LCL_S,UCL_XS,LCL_XS,
    ooc_R,ooc_XR,ooc_S,ooc_XS,
    capacidad: cap
  };
}

/* ===================== GRAFICADOR SIMPLE (SVG) ===================== */
function drawChart(svgEl, series, center, lcl, ucl){
  const w = svgEl.clientWidth, h = svgEl.clientHeight, pad=30;
  const n = series.length;
  const x = i => pad + (w-2*pad) * (i/(n-1));
  const ymin = Math.min(lcl, ...series), ymax = Math.max(ucl, ...series);
  const y = v => h-pad - (h-2*pad) * ((v - ymin) / (ymax - ymin || 1));

  svgEl.innerHTML='';
  const svgns='http://www.w3.org/2000/svg';

  const hline=(yy,color,hdash)=>{
    const L=document.createElementNS(svgns,'line');
    L.setAttribute('x1',pad);L.setAttribute('y1',yy);
    L.setAttribute('x2',w-pad);L.setAttribute('y2',yy);
    L.setAttribute('stroke',color);L.setAttribute('stroke-width','1.5');
    L.setAttribute('stroke-dasharray',hdash);
    svgEl.appendChild(L);
  };
  hline(y(center),'#22c55e','4 4');      // Media (verde punteada)
  hline(y(lcl),'#f87171','6 4');         // LCL (rojo)
  hline(y(ucl),'#f87171','6 4');         // UCL (rojo)

  // Serie
  const path=document.createElementNS(svgns,'path');
  let d=''; series.forEach((v,i)=>{ const X=x(i), Y=y(v); d+=(i===0?`M${X} ${Y}`:` L${X} ${Y}`); });
  path.setAttribute('d',d); path.setAttribute('fill','none');
  path.setAttribute('stroke','#0f766e'); path.setAttribute('stroke-width','2');
  svgEl.appendChild(path);

  // Puntos
  series.forEach((v,i)=>{
    const c=document.createElementNS(svgns,'circle');
    c.setAttribute('cx',x(i)); c.setAttribute('cy',y(v));
    c.setAttribute('r',3); c.setAttribute('fill','#0284c7');
    svgEl.appendChild(c);
  });
}

/* ===================== RUNTIME / UI ===================== */
let lastState = null;

function renderAll(state){
  const {data, params, res} = state;
  // Resumen
  const s = document.getElementById('summary');
  const cap = res.capacidad;
  s.innerHTML =
  `<div class="small">
    <div><b>m</b>=${params.m}, <b>n</b>=${params.n} <span class="muted">(orientación: ${params.mode})</span></div>
    <div>X̄̄=${rnd(res.xbarbar)} &nbsp; R̄=${rnd(res.Rbar)} &nbsp; S̄=${rnd(res.Sbar)}</div>
    <div>X̄–R: LCLx=${rnd(res.LCL_XR)}, UCLx=${rnd(res.UCL_XR)} | LCLr=${rnd(res.LCL_R)}, UCLr=${rnd(res.UCL_R)}</div>
    <div>X̄–S: LCLx=${rnd(res.LCL_XS)}, UCLx=${rnd(res.UCL_XS)} | LCLs=${rnd(res.LCL_S)}, UCLs=${rnd(res.UCL_S)}</div>
    ${
      cap ? `<div>Capacidad σ̂(R)=${rnd(cap.sigma_R)} → Cp=${rnd(cap.Cp_R)}, Cpk=${rnd(cap.Cpk_R)}</div>
             <div>Capacidad σ̂(S)=${rnd(cap.sigma_S)} → Cp=${rnd(cap.Cp_S)}, Cpk=${rnd(cap.Cpk_S)}</div>`
          : `<div class="muted">Ingrese LSL y USL para ver Cp/Cpk.</div>`
    }
  </div>`;

  // OOC
  const o = document.getElementById('ooc');
  const fmt = a => a.length? a.join(', ') : '—';
  const anyOOC = res.ooc_R.length || res.ooc_S.length || res.ooc_XR.length || res.ooc_XS.length;
  o.innerHTML =
    `<div class="small ${anyOOC?'danger':'success'}">
       <b>${anyOOC ? '⚠ Se detectaron puntos fuera de control' : '✅ Todos los puntos están bajo control'}</b><br>
       OOC R: <b>${fmt(res.ooc_R)}</b> &nbsp;|&nbsp;
       OOC X̄(R): <b>${fmt(res.ooc_XR)}</b> &nbsp;|&nbsp;
       OOC S: <b>${fmt(res.ooc_S)}</b> &nbsp;|&nbsp;
       OOC X̄(S): <b>${fmt(res.ooc_XS)}</b>
     </div>`;

  // Gráficas
  drawChart(document.getElementById('svgR'),  res.R,    res.Rbar,   res.LCL_R,  res.UCL_R);
  drawChart(document.getElementById('svgXR'), res.xbar, res.xbarbar,res.LCL_XR, res.UCL_XR);
  drawChart(document.getElementById('svgS'),  res.S,    res.Sbar,   res.LCL_S,  res.UCL_S);
  drawChart(document.getElementById('svgXS'), res.xbar, res.xbarbar,res.LCL_XS, res.UCL_XS);

  document.getElementById('debug').textContent = JSON.stringify(state,null,2);
}

async function handleCSV(){
  const file = document.getElementById('fileCsv').files[0];
  if(!file){ alert("Selecciona un archivo CSV."); return; }
  const text = await file.text();
  const matrix = parseCSV(text);
  const {data, n, m, mode} = orientGroups(matrix);

  // Sugerir LSL/USL si están vacíos (min/max ± 1% del rango)
  const flat = data.flat();
  const minV = Math.min(...flat), maxV = Math.max(...flat);
  const lslEl = document.getElementById('lsl'), uslEl = document.getElementById('usl');
  const autoLSL = minV - 0.01*(maxV-minV), autoUSL = maxV + 0.01*(maxV-minV);
  const lsl = lslEl.value!=='' ? Number(lslEl.value) : autoLSL;
  const usl = uslEl.value!=='' ? Number(uslEl.value) : autoUSL;

  const res = computeAll(data, n, m, lsl, usl);
  lastState = { data, params:{n,m,lsl,usl,mode}, res };
  document.getElementById('status').textContent = `CSV OK • m=${m}, n=${n}`;
  renderAll(lastState);
}

/* Botón demo (por si quieres mostrar sin CSV) */
function simulate(m,n,mu=100,sigma=2){
  const randn=()=>{let r=0;for(let i=0;i<12;i++)r+=Math.random();return r-6;}
  const out=[]; for(let i=0;i<m;i++){ const row=[]; for(let j=0;j<n;j++) row.push(mu+sigma*randn()); out.push(row); }
  return out;
}

document.getElementById('btnProcesar').addEventListener('click', handleCSV);
document.getElementById('btnEjemplo').addEventListener('click', ()=>{
  const data = simulate(25,5,40,0.5);  // parecido a tu captura
  const n=5,m=25, lsl=39, usl=41;
  const res = computeAll(data,n,m,lsl,usl);
  lastState = { data, params:{n,m,lsl,usl,mode:"demo"}, res };
  document.getElementById('status').textContent = `Demo local • m=${m}, n=${n}`;
  renderAll(lastState);
});
</script>
</body>
</html>

